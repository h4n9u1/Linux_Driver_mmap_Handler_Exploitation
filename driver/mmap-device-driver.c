#include "mmap-device-driver.h"

struct char_dev *char_devs;

static int dev_open(struct inode *inodep, struct file *filep)
{
    printk( KERN_INFO "H4N9U1: Device has been opened\n");
    filep->private_data = kzalloc(SIZE, GFP_KERNEL);
    if (filep->private_data == NULL)
        return -1;
    return 0;
}

static int dev_mmap(struct file *filep, struct vm_area_struct *vma)
{
    printk( KERN_INFO "H4N9U1: Device mmap\n" );

    if(remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff >> PAGE_SHIFT, \
                vma->vm_end - vma->vm_start, vma->vm_page_prot))
    {
        printk(KERN_INFO "H4N9U1: Device mmap failed\n");
        return -EAGAIN;
    }

    printk(KERN_INFO "H4N9U1: Device has been closed\n");
    return 0;
}

static int dev_release(struct inode *inodep, struct file *filep)
{
    printk(KERN_INFO "H4N9U1: Device has been closed\n");
    kfree(filep->private_data);
    return 0;
}

static struct file_operations fops = {
    .open = dev_open,
    .mmap = dev_mmap,
    .release = dev_release,
};

int register_device(void)
{
    int result = 0;
    printk(KERN_INFO "H4N9U1: Device Register Start");
    dev_t dev = MKDEV(DRIVER_MAJOR, DRIVER_MINOR);

    result = register_chrdev_region(dev, 1, "Driver-H4N9U1");
    if(result < 0)
    {
        printk(KERN_WARNING "H4N9U1: Can\'t get major %d\n", DRIVER_MAJOR);
        return result;
    }

    char_devs = kmalloc(sizeof(struct char_dev), GFP_KERNEL);
    if(!char_devs)
    {
        result = -ENOMEM;
        return result;
    }

    memset(char_devs, 0, sizeof(struct char_dev));
    cdev_init(&char_devs->cdev, &fops);
    char_devs->cdev.ops = &fops;
    result = cdev_add(&char_devs->cdev, dev, 1);
    return 0;
}

void unregister_device(void)
{
    printk(KERN_ALERT "H4N9U1: Device Unregister Start");
    dev_t dev = MKDEV(DRIVER_MAJOR, DRIVER_MINOR);

    if(char_devs)
    {
        cdev_del(&char_devs->cdev);
        kfree(char_devs);
    }
    unregister_chrdev_region(dev, 1);
}
